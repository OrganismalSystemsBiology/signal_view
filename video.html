<html>
    <body>
        <div id="app">
            <video id="mouseVideo" ref="mouseVideo" controls v-if="src" muted :src="src" :height="videoHeight" :width="videoWidth"></video>
        </div>
        <script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"></script>
        <script>
            var moment = require('moment')
            var path = require('path')
            var {remote} = require('electron');
            const fs = require('fs');
            const parse = require('csv-parse/lib/sync');
            var args = remote.getGlobal('sharedObject').args
            var faster_dir = args[2]
            var device_id = args[3]
            function readCsvSync(filename, options) {
                const content = fs.readFileSync(filename).toString();
                return parse(content, options);
            }

        </script>
        <script>
            // set the analysis start datetime from exp.info.csv
            expInfoPath = faster_dir + "data\\exp.info.csv"
            res = readCsvSync(expInfoPath, {columns:false, from_line: 2});
            startDT = moment(res[0][2])
            endDT = moment(res[0][3])
            console.log(startDT)
            startDTStr = this.startDT.format("YYYY/MM/DD HH:mm:ss")
        </script>
        <script>
            // process video.info.csv
            videoInfoPath = path.join(faster_dir, "video", device_id, "video.info.csv")
            res = readCsvSync(videoInfoPath, {columns:false, from_line: 2});
            videoInfo = []
            for (i=0; i<res.length; i++){
                r = res[i]
                video_startDT = moment(r[1])
                video_endDT   = moment(r[2])
                videoInfo.push({'filename': r[0], 
                                'start_dt': video_startDT,
                                'end_dt': video_endDT,
                                'start_a': video_startDT.diff(startDT), // analysis time of start: milliseconds relative to the analysis start
                                'end_a': video_endDT.diff(startDT), // analysis time of end: milliseconds relative to the analysis start
                                'offset': parseFloat(r[3])})
            }
            console.log(videoInfo)

            // construct a mapping list from epoch index to video&position
            epochNum = Math.floor(endDT.diff(startDT, 'seconds') / 8)
            epochVideoList = Array(epochNum)
            videoInfoCounter = 0
            for (i=0; i<epochNum; i++){
                epochTime = i * 8 * 1000 // milliseconds
                vi = videoInfo[videoInfoCounter]
                // skip the epoch if it is before the video
                if (epochTime < vi['start_a']){
                    epochVideoList[i] = {'video_src': 'noVideo', 'position': 0}
                    continue
                }

                if (epochTime < vi['end_a']) {
                    epochVideoList[i] = {'video_src': vi['filename'], 
                                         'position': (epochTime - vi['start_a'])/1000 // seconds
                                        }
                } else {
                    // seek the videoInfoCounter to cover the epochTime
                    while ( (epochTime >= vi['end_a']) && ((videoInfo.length - 1) > videoInfoCounter) ){
                        videoInfoCounter += 1
                        vi = videoInfo[videoInfoCounter]
                    }
                    if (videoInfoCounter < (videoInfo.length - 1)){
                        epochVideoList[i] = {'video_src': vi['filename'], 
                                             'position': (epochTime - vi['start_a'])/1000 // seconds
                                            }    
                    } else {
                        epochVideoList[i] = {'video_src': 'noVideo', 'position': 0}
                    }        
                }
            }
            console.log(epochVideoList)
        </script>

        <script>
            new Vue({
                el: '#app',
                data: {
                    src: null,
                    isLoading: false,
                    focusTime: 0,
                    fasterDir: null,
                    startDT: null,
                    startDTStr: startDTStr,
                    videoHeight: 240,
                    videoWidth: 340
                },
                mounted() {
                    window.addEventListener('message', (e) => {
                        switch (e.data.action) {
                            case 'seek':
                                idx = e.data.message
                                this.seekVideo(idx)
                                break
                        }
                    }),
                    window.addEventListener('resize', this.handleResize)
                },
                methods: {
                    seekVideo(idx){
                        src = path.join(faster_dir, 'video', device_id, epochVideoList[idx]['video_src'])
                        if (src != this.src){
                            this.src = src
                            this.$refs.mouseVideo.src = src
                            this.$refs.mouseVideo.currentTime = epochVideoList[idx]['position']
                            console.log('current time', this.$refs.mouseVideo.currentTime)
                        }else{
                            this.$refs.mouseVideo.currentTime = epochVideoList[idx]['position']
                            console.log('current time', this.$refs.mouseVideo.currentTime)
                        }
                    },
                    handleResize: function () {
                        this.videoHeight = window.innerHeight;
                        this.videoWidth = window.innerWidth;
                    }
                }
            })
        </script>
    </body>
</html>